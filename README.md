# 如何设计一个比特币钱包服务

## 概述
总所周知，比特币全节点的实现目前有两个版本，一个是中本聪c++写的原版bitcoin core，一个是go语言写的btcd。这两个版本从功能上并没有多大差异，都实现了比特币协议。从理论上讲，比特币网络中的每个全节点只要遵循相同的比特币协议，至于用什么语言实现，节点数据如何存储都是无所谓的。bitcoin core和btcd都没有实现通用的钱包服务，这里说的钱包服务指的是一个可以给钱包app提供所数据的服务，私钥保存在钱包app中，用户交易是在钱包app中签名，再将签名数据发给钱包服务，再由钱包服务转发到全节点上链。所幸的是全节点提供了一些JSON RPC接口，通过这些接口可以读取区块数据和发起转账交易。但是能读到的数据太原始了，就连获取某个地址的余额都做不到。因为比特币使用的是UTXO账号体系，并没有一个统一的地方存储地址余额，只有UTXO，而UTXO是分散在每个区块中的，要想知道某个地址的UTXO，需要从第一个区块开始遍历。有些人说这样设计可以更高的并发执行，这个真的不敢苟同，可以更好的溯源倒是真的，每一笔交易都可以追溯到上一笔交易，上上一笔交易。

## 钱包服务功能
好了，废话不多说，我们看一下一个钱包服务应该具备什么样的功能。

* （1）查询任意一个地址的余额，钱包需要知道自己地址的余额。
* （2）查询任意一个地址的UTXO，钱包转账时需要UTXO来签名打包。
* （3）发起转账交易。钱包需要调服务发起转账交易。
* （4）查询任意一个地址的历史交易记录。
* （5）查询最新区块高度，钱包转账后通过区块高度来计算交易是否已经确认，比特币是6个区块确认。

第(1)(2)点实际上是一个问题,知道UTXO自然就知道余额了。第(3)(4)可以直接调全节点接口。所以钱包服务只的难点只剩下(2)(4)这两个功能。钱包服务要做的就是从全节点从第一个区块开始遍历读取所有的交易记录，并推到出每个地址当前区块高度的UTXO，将每个地址的历史交易记录和UTXO保存到数据库中方便使用。

## 全节点选择
bitcoin core 虽然是原版的比特币全节点，但是他只提供了http接口，没有websocket接口，不能实时推送未上链的交易。一个体验好的钱包不仅要获取已经上链的交易记录，也要知道未上链的交易。所以我们选择了btcd作为全节点。

## 数据库选型
到目前为止（2018-12-26）比特币的交易量是3.6亿条，因为一笔交易涉及到多个输入和多个输出，解析出来后大约是16.6亿条（这个我自己跑的数据）。若是用传统的关系型数据库肯定扛不住的，所以一般人都会往nosql或者列式数据库方向考虑，比如用mongo或cassandra等。虽然能够解决问题，但是面对这么大的数据，这类型的数据库都需要部署分片集群。对于一个小创业公司来说，如果用户不是很多，从运维成本上来看，是不是都点杀鸡用牛刀大感觉呢。有没有更好的方案？当然有，比如leveldb和rocksdb。

## 数据结构设计
(未完)







